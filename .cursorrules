# React Common Library - Cursor Rules

## Frontend Standards

### TypeScript Standards
- **ALWAYS** use TypeScript strict mode
- **ALWAYS** define proper interfaces for all data structures
- **ALWAYS** avoid `any` type - use proper typing
- **ALWAYS** use meaningful type names
- **ALWAYS** implement proper error handling

### React Patterns
- **ALWAYS** use functional components with hooks
- **ALWAYS** implement proper state management
- **ALWAYS** use proper prop types and interfaces
- **ALWAYS** implement error boundaries
- **ALWAYS** use proper key props for lists

### API Integration
- **ALWAYS** use centralized API client
- **ALWAYS** implement proper error handling for API calls
- **ALWAYS** use loading states for async operations
- **ALWAYS** implement proper data fetching patterns
- **ALWAYS** handle network errors gracefully

### Code Organization
- **ALWAYS** organize components in logical folders
- **ALWAYS** use descriptive component names
- **ALWAYS** separate business logic from UI components
- **ALWAYS** implement reusable components
- **ALWAYS** use proper file naming conventions

### Frontend Checklist
- [ ] TypeScript strict mode enabled
- [ ] Proper interfaces defined
- [ ] No `any` types used
- [ ] Error boundaries implemented
- [ ] Centralized API client
- [ ] Loading states implemented
- [ ] Components properly organized
- [ ] Reusable components created

## CSS Separation Standards

### Critical Rule: NO INLINE STYLES
- **NEVER** use inline styles (`style=` attributes)
- **ALWAYS** use CSS classes for styling
- **ALWAYS** separate CSS into dedicated `.css` files
- **ALWAYS** use meaningful class names

### CSS Architecture
- **Global Styles**: Use `index.css` for global styles
- **Component Styles**: Use `App.css` or component-specific CSS files
- **CSS Modules**: Consider CSS modules for component isolation
- **CSS-in-JS**: Avoid unless absolutely necessary

### File Organization
```
src/
├── index.css          # Global styles and CSS reset
├── App.css           # Main application styles
├── components/
│   ├── Component.tsx  # Component logic only
│   └── Component.css  # Component styles (if needed)
└── styles/           # Shared style utilities
    ├── variables.css  # CSS custom properties
    └── mixins.css     # CSS mixins
```

### Anti-Patterns (NEVER DO)
```tsx
// ❌ WRONG - Inline styles
<div style={{color: 'red', fontSize: '16px'}}>Hello</div>

// ❌ WRONG - Inline styles with variables
<div style={{color: theme.primary, fontSize: '16px'}}>Hello</div>
```

### Correct Patterns (ALWAYS DO)
```tsx
// ✅ CORRECT - CSS classes
<div className="error-message">Hello</div>

// ✅ CORRECT - Conditional classes
<div className={`message ${isError ? 'error' : 'success'}`}>Hello</div>
```

### CSS Checklist
- [ ] No inline styles used
- [ ] All styles in CSS files
- [ ] Meaningful class names
- [ ] CSS properly organized
- [ ] No style attributes in JSX

## TypeScript Code Style

### TypeScript Standards
- **ALWAYS** use TypeScript strict mode
- **ALWAYS** use meaningful type names
- **ALWAYS** use consistent naming conventions
- **ALWAYS** avoid `any` type
- **ALWAYS** use proper error handling

### TypeScript Code Quality Metrics
- **Zero** code duplication
- **100%** test coverage for critical paths
- **Zero** linting errors
- **All** components properly typed
- **All** props properly validated

### TypeScript Code Style Checklist
- [ ] TypeScript strict mode enabled
- [ ] Meaningful type names used
- [ ] Consistent naming conventions
- [ ] No `any` types used
- [ ] Proper error handling
- [ ] No code duplication
- [ ] Linting errors resolved

## React Component Standards

### Component Structure
```tsx
// ✅ CORRECT - Proper component structure
interface ComponentProps {
  title: string;
  isVisible: boolean;
  onAction: (id: string) => void;
}

const Component: React.FC<ComponentProps> = ({ 
  title, 
  isVisible, 
  onAction 
}) => {
  const [state, setState] = useState<string>('');
  
  const handleClick = useCallback((id: string) => {
    onAction(id);
  }, [onAction]);

  if (!isVisible) return null;

  return (
    <div className="component">
      <h2>{title}</h2>
      <button onClick={() => handleClick('test')}>
        Action
      </button>
    </div>
  );
};

export default Component;
```

### Component Anti-Patterns (NEVER DO)
```tsx
// ❌ WRONG - Any type usage
const Component = (props: any) => {
  return <div>{props.title}</div>;
};

// ❌ WRONG - Inline styles
const Component = () => {
  return <div style={{color: 'red'}}>Hello</div>;
};

// ❌ WRONG - Missing key prop
const List = ({ items }) => {
  return (
    <ul>
      {items.map(item => <li>{item.name}</li>)}
    </ul>
  );
};
```

### Component Checklist
- [ ] Proper TypeScript interfaces defined
- [ ] No `any` types used
- [ ] Proper prop validation
- [ ] Error boundaries implemented
- [ ] Proper key props for lists
- [ ] No inline styles
- [ ] Proper event handling
- [ ] Memoization used when appropriate

## State Management Standards

### State Management Patterns
```tsx
// ✅ CORRECT - Proper state management
const useUserData = () => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchUser = useCallback(async (id: string) => {
    setLoading(true);
    setError(null);
    try {
      const userData = await api.getUser(id);
      setUser(userData);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  }, []);

  return { user, loading, error, fetchUser };
};
```

### State Management Anti-Patterns (NEVER DO)
```tsx
// ❌ WRONG - Direct state mutation
const [user, setUser] = useState({ name: '', email: '' });
user.name = 'John'; // Don't mutate state directly

// ❌ WRONG - Missing loading states
const fetchData = async () => {
  const data = await api.getData();
  setData(data); // No loading state
};

// ❌ WRONG - No error handling
const fetchData = async () => {
  const data = await api.getData(); // No try-catch
  setData(data);
};
```

### State Management Checklist
- [ ] Proper state structure
- [ ] Loading states implemented
- [ ] Error states handled
- [ ] No direct state mutation
- [ ] Proper cleanup in useEffect
- [ ] Memoization used appropriately

## API Integration Standards

### API Client Pattern
```tsx
// ✅ CORRECT - Centralized API client
class ApiClient {
  private baseURL: string;

  constructor(baseURL: string) {
    this.baseURL = baseURL;
  }

  async get<T>(endpoint: string): Promise<T> {
    const response = await fetch(`${this.baseURL}${endpoint}`);
    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }
    return response.json();
  }

  async post<T>(endpoint: string, data: unknown): Promise<T> {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }
    return response.json();
  }
}

export const apiClient = new ApiClient(process.env.REACT_APP_API_URL || '');
```

### API Integration Anti-Patterns (NEVER DO)
```tsx
// ❌ WRONG - Hardcoded URLs
const fetchData = async () => {
  const response = await fetch('http://localhost:3000/api/data');
  return response.json();
};

// ❌ WRONG - No error handling
const fetchData = async () => {
  const response = await fetch('/api/data');
  return response.json(); // No error handling
};

// ❌ WRONG - No loading states
const Component = () => {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    fetchData().then(setData); // No loading state
  }, []);
  
  return <div>{data?.name}</div>;
};
```

### API Integration Checklist
- [ ] Centralized API client
- [ ] Proper error handling
- [ ] Loading states implemented
- [ ] No hardcoded URLs
- [ ] Proper TypeScript types
- [ ] Request/response interceptors
- [ ] Timeout handling

## Testing Standards

### Component Testing
```tsx
// ✅ CORRECT - Component testing
import { render, screen, fireEvent } from '@testing-library/react';
import { Component } from './Component';

describe('Component', () => {
  it('renders with correct props', () => {
    render(<Component title="Test" isVisible={true} onAction={jest.fn()} />);
    expect(screen.getByText('Test')).toBeInTheDocument();
  });

  it('calls onAction when button is clicked', () => {
    const mockAction = jest.fn();
    render(<Component title="Test" isVisible={true} onAction={mockAction} />);
    
    fireEvent.click(screen.getByRole('button'));
    expect(mockAction).toHaveBeenCalledWith('test');
  });

  it('does not render when isVisible is false', () => {
    render(<Component title="Test" isVisible={false} onAction={jest.fn()} />);
    expect(screen.queryByText('Test')).not.toBeInTheDocument();
  });
});
```

### Testing Anti-Patterns (NEVER DO)
```tsx
// ❌ WRONG - Testing implementation details
const component = render(<Component />);
expect(component.state.isVisible).toBe(true); // Don't test state directly

// ❌ WRONG - No cleanup
afterEach(() => {
  // Missing cleanup
});

// ❌ WRONG - Testing multiple things in one test
it('renders and handles click and updates state', () => {
  // Too many assertions in one test
});
```

### Testing Checklist
- [ ] Components tested in isolation
- [ ] User interactions tested
- [ ] Error states tested
- [ ] Loading states tested
- [ ] Props validation tested
- [ ] Cleanup implemented
- [ ] Mock external dependencies
- [ ] Test accessibility

## Performance Standards

### React Performance
- **ALWAYS** use React.memo for expensive components
- **ALWAYS** use useMemo for expensive calculations
- **ALWAYS** use useCallback for event handlers
- **ALWAYS** implement proper key props for lists
- **ALWAYS** avoid unnecessary re-renders

### Performance Patterns
```tsx
// ✅ CORRECT - Performance optimizations
const ExpensiveComponent = React.memo(({ data, onAction }) => {
  const processedData = useMemo(() => {
    return data.map(item => ({ ...item, processed: true }));
  }, [data]);

  const handleClick = useCallback((id: string) => {
    onAction(id);
  }, [onAction]);

  return (
    <div>
      {processedData.map(item => (
        <Item key={item.id} data={item} onClick={handleClick} />
      ))}
    </div>
  );
});
```

### Performance Anti-Patterns (NEVER DO)
```tsx
// ❌ WRONG - Creating objects in render
const Component = ({ items }) => {
  return (
    <div>
      {items.map(item => (
        <Item key={item.id} style={{color: 'red'}} data={item} />
      ))}
    </div>
  );
};

// ❌ WRONG - Missing dependencies in useEffect
useEffect(() => {
  fetchData(userId); // userId not in dependencies
}, []);

// ❌ WRONG - Unnecessary re-renders
const Component = ({ data }) => {
  const processedData = data.map(item => ({ ...item, processed: true }));
  return <div>{processedData.length}</div>;
};
```

### Performance Checklist
- [ ] React.memo used appropriately
- [ ] useMemo for expensive calculations
- [ ] useCallback for event handlers
- [ ] Proper key props for lists
- [ ] No objects created in render
- [ ] Proper useEffect dependencies
- [ ] Bundle size optimized
- [ ] Images optimized

## Accessibility Standards

### Accessibility Requirements
- **ALWAYS** use semantic HTML elements
- **ALWAYS** provide proper ARIA labels
- **ALWAYS** ensure keyboard navigation
- **ALWAYS** provide alternative text for images
- **ALWAYS** test with screen readers

### Accessibility Patterns
```tsx
// ✅ CORRECT - Accessible component
const Button = ({ children, onClick, disabled, ariaLabel }) => {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      aria-label={ariaLabel}
      className="button"
    >
      {children}
    </button>
  );
};

const Modal = ({ isOpen, onClose, title, children }) => {
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'unset';
    }
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div 
        className="modal-content" 
        onClick={e => e.stopPropagation()}
        role="dialog"
        aria-modal="true"
        aria-labelledby="modal-title"
      >
        <h2 id="modal-title">{title}</h2>
        {children}
      </div>
    </div>
  );
};
```

### Accessibility Checklist
- [ ] Semantic HTML used
- [ ] ARIA labels provided
- [ ] Keyboard navigation works
- [ ] Screen reader compatible
- [ ] Color contrast sufficient
- [ ] Focus management implemented
- [ ] Alternative text for images
- [ ] Form labels associated

## Hardcoded Values Prevention

### Critical Rule: NO HARDCODED VALUES
- **NEVER** hardcode URLs, API endpoints, or configuration values
- **ALWAYS** use environment variables or configuration files
- **ALWAYS** provide sensible defaults for development
- **ALWAYS** validate configuration on startup

### Configuration Management
```tsx
// ✅ CORRECT - Configuration-driven
const config = {
  apiUrl: process.env.REACT_APP_API_URL || 'http://localhost:3000',
  timeout: parseInt(process.env.REACT_APP_TIMEOUT || '5000'),
  features: {
    enableAnalytics: process.env.REACT_APP_ENABLE_ANALYTICS === 'true',
  }
};

// ✅ CORRECT - Environment-specific configs
const getApiUrl = () => {
  switch (process.env.NODE_ENV) {
    case 'production':
      return 'https://api.production.com';
    case 'staging':
      return 'https://api.staging.com';
    default:
      return 'http://localhost:3000';
  }
};
```

### Hardcoded Values Anti-Patterns (NEVER DO)
```tsx
// ❌ WRONG - Hardcoded URLs
const fetchData = async () => {
  const response = await fetch('http://localhost:3000/api/data');
  return response.json();
};

// ❌ WRONG - Hardcoded configuration
const TIMEOUT = 5000; // Should be configurable

// ❌ WRONG - Hardcoded feature flags
if (true) { // Should be configurable
  trackEvent('user_action');
}
```

### Hardcoded Values Checklist
- [ ] No hardcoded URLs or endpoints
- [ ] No hardcoded configuration values
- [ ] Environment variables used
- [ ] Configuration files implemented
- [ ] Sensible defaults provided
- [ ] Configuration validated on startup
